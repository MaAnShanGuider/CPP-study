## 位运算
再来看看位运算，一共有六种位操作符。

|- 符号 |- 描述
|- |-
| `&` | 按位 "与" (AND)
| `|` | 按位 "或" (OR)
| `^` | 按位 "异或" (XOR)
| `~` | 取反 (NOT)
| `>>` | 数据右移
| `<<` | 数据左移

## 先解释解释八位二进制数

八位（8bit）是一个字节，计算机中只要一个字节就可以存放ASCII编码，就是所有的数字、大小写字母和一些特殊字符（总共255个）。所以在计算机中对用户来说有意义的单位就是字节，这是我们可以看懂的。

八位的二进制数最大值就是255，刚好表示255个ASCII字符。

我们汉字使用的是unicode编码的，unicode编码要用两个字节，所以要存放16位二进制数才能代表一个unicode字符。

另外还有UTF8编码占四个字节，等等。

再来讲讲，1111 1111 是255， 那么256怎么用二进制表示呢
```
    256
    0000 0001 0000 0000
    // 这样表示就可以了。
```

我们知道，内存中最小的单位是一个字节，而一个字节是八位二进制即 `0000 0000`,
那第二小的单位是什么?

自然是两个字节 `0000 0000 0000 0000`, 前面八个0称为高字节区，后面八个0称为低字节区。

总而言之，如果一个字节表示不了，那就两个字节，两个也不行，就肆字节，肆字节不够，就捌字节。
反正就是1, 2, 4, 8, 16, ...。

## 一，与运算
原理:

与运算符 `&` 的作用是对运算符两侧以二进制表达的操作数分别进行与运算，而这运算是以数中相同的位(bit)为单位的。

规则:

仅当两个操作数都为1时，输出的结果才为1，否则为0.

例如:
```
    // 以0x开头的为十六进制数
    a = 0x88
    b = 0x81

    // 则a&b的运算结果如下:
    0x88    1000 1000 a
    &
    0x81    1000 0001 b

    = 1000 0000

```
其中，&运算符让a数0x88与B数0x81的1位与1位、2位与2位……7位与7位分别相“与”。由于“与”运算的操作规则是，两个操作数中各位只要有1个为0，其结果中对应的位就为0。而a数与b数中只有最高位(第7位)均为1，因而该位结果为1，其它各位结果都为0。

总结，大家都为1，那么就返回1。至少有一个不为1，那么就返回0。

用途:
通常我们可把与操作 `&` 作为关闭某位(即将该位置0)的手段，例如我们想要关闭a数中第三位，而又不影响其他位的现状，可以用一个数0xf7,即二进制数11110111去a数作与运算。
```
    0x88    1000 1000 a
    &
    0xf7    1111 0111 屏蔽数

    = 1000 0000
```
注意，这个数除第三位为0外，其他各位均为1，操作的结果只会将a数中的第3位置0，而a的其他位不受影响。

上面的运算可以用 `a = a&(0xf7)` 来表示，也可以用 `a&=(0xf7)` 来表示。这两个式子的作用是相同的，但是在源程序代码中，一般都会是第二种。

## 或运算
按位“或”运算符|的作用是对运算符两侧以二进制表达的操作数按位分别进行“或”运算，而这一运算是以数中相同的位(bit)为单位的。操作的规则是：仅当两个操作数都为0时，输出的结果才为0，否则为1。

```
    a=0x88，b=0x81，则a|b的运算结果如下：
    0x88  10001000  a数

    |
    0x81  10000001  b数

    =10001001
```

用途:

我们通常可把或操作 `|` 作为置位(即该位置1)的手段，例如我们想要将a数中的第0位和1位置1，而又不影响其他位的现状。可以用一个数0x03,即二进制数00000011去与a数作或运算。
```
    0x88 1000 1000 a
    |
    0x03 0000 0011 置位数
    = 1000 1011
```
注意，这个数除第0、1位为1外，其它各位均为0，操作的结果只会将a数中的第0、1位置0，而a数的其它位不受影响。也就是说，若需要某个数的第n位置1，只需要将该数与另一个数按位相“或”，另一个数除了相应的第n位为1外，其它各位都为0，以起到对其它各位的屏蔽作用。上面的运算可以用a=a|(0xF7)来表示，也可以用a|=(0xF7)来表达。

## 按位 "异或" 运算
按位“异或”运算符^的作用是对运算符两侧以二进制表达的操作数按位分别进行“异或”运算，而这一运算是以数中相同的位(bit)为单位的。异或运算操作的规则是：仅当两个操作数不同时，相应的输出结果才为1，否则为0。不同为1，相同为0。
```
    a = 0x88, b = 0x81

    0x88 1000 1000 a
    ^
    0x81 1000 0001 异或数
    = 0000 1001
```
用途:

(1) 异或运算可以使特定的位取反

例如，我们想要a中的最低位和最高位取反，只要用0x81,即二进制数1000 0001去与它做异或运算，运算结果同上面那样。经过操作后，最高位的值已经由1变为0。而最低位的值也已经由0变1，起到了使这两位翻转的效果。其他位的状态保持不变。

可以看到，这个数除了最低位，最高位为1外，其他各位均为0，操作的结果只会将a中的第0,7位取反，而a数的其他位不受影响。也就是说，若需要某个数的第n位取反，只需要将该数与另一个数进行异或运算，另一个数除了相应的第n位为1外，其他各位都为0,以起到对其他各位的屏蔽作用。上面的运算可以用 `a = a^(0x81)` 来表示，也可以用 `a^=(0x81)`来表示。

(2)直接交换两个变量的值

例如，若有变量 `a = 3` , `b = 4` ,想要交换他们的值，可以做如下操作:
```
    a ^= b;
    b ^= a;
    a ^= b;

    首先 a ^= b;
    0000 0011 a
    ^
    0000 0100 b
    = 0000 0111
    a = 0000 0111
    其次， b ^= a
    0000 0100 b
    ^
    0000 0111 a
    = 0000 0011
    b = 0000 0011
    最后 a ^b
    0000 0111 a
    ^
    0000 0011 b
    = 0000 0100
    a = 0000 0100
```
这样， a,b两个变量的值，就进行了对调，这种操作比临时变量的方式高效很多。

## 取反运算
取反运算符 `~` 的作用是将各位数字取反：所有的0置位1,1置位0。
例如:
```
    ~1001 0110
    = 0110 1001
```

## 数据右移
数据右移操作符 `>>` 将变量的各位按要求向右移动若干位。右移语句的通常形式是:
```
    variable >> 右移位数
```
如:
```
    a = 1111 0000;
    a = a>>2
    a // 0011 1100
```
## 数据左移
数据左移操作符 `<<` 将变量的各位按要求向左移动若干位。左移语句的通常形式是:
```
    variable << 左移位数
```
如:
```
    a = 1111 0000;
    a = a<<2
    a // 1100 0000
```

> 注意: 无论左移或者右移，当某位从一端移出时，另一端出现的空白将从外面移入的0(某些计算机时1)来补充。这说明，移位不同于循环，从一端移出去的位并不会送到另一端去，移去的位永远丢失了，同时再另一端只能补上相应位数0。

用途:

移位操作可用于整数的快速乘除运算，左移移位等效于乘以2，而右移移位等效于除以2。
如: x=7, 二进制表达为: 0000 0111

* x << 1 : `0000 1110`,相当于 `x=2*7=14`
* x << 3 : `0111 0000`,相当于 `x=14 * 2 * 2 * 2 = 112`
* x << 2 : `1100 0000`, `x = 192`

在作第三次左移时，其中一位为1的位移到外面去了，而左边只能以0补齐，因而便不等于112*2*2=448，而是等于192了。当x按刚才的步骤反向移动回去时，就不能返回到原来的值了，因为左边丢掉的一个1，再也不能找回来了。

右移除法也是一样的:
此时，`x=1100 0000`, 192

* x >> 2 : `0011 0000`, `x=192 / 4 = 48`
* x >> 3 : `0000 0110`, `x=48 / 8 = 6`
* x >> 1 : `0000 0011`, `x=6 / 2 =3`
